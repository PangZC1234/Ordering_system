import './App.css';
import React, { useState, useEffect } from 'react';
import { useNavigate } from "react-router-dom";
import axios from 'axios';
import 'bootstrap/dist/css/bootstrap.css';
import { Container, Table, Button, Form, Modal, Navbar, Card, Accordion } from 'react-bootstrap';

axios.defaults.xsrfCookieName = 'csrftoken';
axios.defaults.xsrfHeaderName = 'X-CSRFToken';
axios.defaults.withCredentials = true;

const client = axios.create({
  baseURL: "http://localhost:8000"
});

// Automatically add CSRF token to requests
client.interceptors.request.use(config => {
  const csrfToken = window.csrfToken;
  if (csrfToken) {
    config.headers['X-CSRFToken'] = csrfToken;
  }
  return config;
}, error => {
  return Promise.reject(error);
});

const AdminPage = ({ onLogout }) => {
  const navigate = useNavigate();
  const [formData, setFormData] = useState({});
  const [tables, setTables] = useState({ categories: [], menus: [], diningTables: [], orders: [] });
  const [showModal, setShowModal] = useState(false);
  const [newRecord, setNewRecord] = useState();
  const [loading, setLoading] = useState(true); // Loading state

  function submitLogout(e) {
    e.preventDefault();
    client.post(
      "/api/logout",
      {withCredentials: true}
    ).then(onLogout());
  }

  useEffect(() => {
    fetchData();
  }, []);

  const fetchResourceDataAndOptions = async (resourceUrl) => {
    try {
      const [data, options] = await Promise.all([
        client.get(resourceUrl),
        client.options(resourceUrl),
      ]);
      return { data: data.data, options: options.data };
    } catch (error) {
      console.error('Failed to fetch data for ${resourceUrl}:', error);
      return null;
    }
  };
  
  const fetchData = async () => {
    try {
      const resources = await Promise.all([
        fetchResourceDataAndOptions('/api/categories/'),
        fetchResourceDataAndOptions('/api/menus/'),
        fetchResourceDataAndOptions('/api/dining-tables/'),
        fetchResourceDataAndOptions('/api/orders/'),
      ]);
      const [categories, menus, diningTables, orders] = resources;
      setTables({ categories, menus, diningTables, orders });
    } catch (error) {
      console.error('Failed to fetch data:', error);
    } finally {
      setLoading(false); // Set loading to false after check is complete
    };
  };  

  const handleSubmit = async (e) => {
    e.preventDefault();
    const formDataObj = new FormData(e.target);
    const { table, id } = formData;

    try {
      if (id) {
        await client.put(`/api/${table}/${id}/`, formDataObj);
      } else {
        await client.post(`/api/${table}/`, formDataObj);
      }
      setShowModal(false);
      fetchData(table);
      setFormData({});
    } catch (error) {
      console.error('Failed to submit form:', error);
    }
  };

  const handleEdit = (table, item, schema) => {
    // Set the form data to the item to edit
    setNewRecord(false);
    setFormData({table, item, schema});
    setShowModal(true);
  };

  const handleNew = (table, item, schema) => {
    setNewRecord(true);
    setFormData({table, item, schema});
    setShowModal(true);
  };

  const handleDelete = async (table, id) => {
    if (window.confirm('Are you sure you want to delete this item?')) {
      try {
        await client.delete(`/api/${table}/${id}/`);
        fetchData();
      } catch (error) {
        console.error('Failed to delete item:', error);
      }
    }
  };


  const renderTable = (tableName, items) => {
    if (items.length === 0) {
      return <p>No data available</p>;
    }
    else{
      const headers = Object.keys(items.data[0]);
      if (loading) {
        return <div>Loading...</div>;
      }
      return (
        <Accordion.Item eventKey={tableName} key={tableName}>
          <Accordion.Header>{tableName}</Accordion.Header>
          <Accordion.Body>
            <Button onClick={() => handleNew(tableName, items.data[0], items.options.actions.POST)}>New</Button>
            <Table striped bordered hover>
              <thead>
                <tr>
                  {headers.map(header => (
                    <th key={header}>{header}</th>
                  ))}
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                {items.data.map(item => (
                  <tr>
                    {headers.map(header => (
                      <td>{item[header]}</td>
                    ))}
                    <td>
                      <Button variant="warning" size="sm" onClick={() => handleEdit(tableName, item, items.options.actions.POST)}>Edit</Button>
                      <Button variant="danger" size="sm" onClick={() => handleDelete(tableName, item.id)}>Delete</Button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </Table>
          </Accordion.Body>
        </Accordion.Item>
      );
    }
  };

  return (
    <div>
        <Navbar bg="dark" variant="dark">
        <Container>
            <Navbar.Text>
            <Button type="submit" variant="light" onClick={() => navigate(-1)}>Back</Button>
            </Navbar.Text>
            <Navbar.Brand>Ordering system</Navbar.Brand>
            <Navbar.Collapse className="justify-content-end">
            <Navbar.Text>
                <form onSubmit={e => submitLogout(e)}>
                <Button type="submit" variant="light">Log out</Button>
                </form>
            </Navbar.Text>
            </Navbar.Collapse>
        </Container>
        </Navbar>
        <h1>Admin Page</h1>

        <Accordion>
        {Object.entries(tables).map(([tableName, items]) => renderTable(tableName, items))}
        </Accordion>
        
        <Modal show={showModal} onHide={() => setShowModal(false)}>
        <Modal.Header closeButton>
          <Modal.Title>{newRecord ? 'Add to' : 'Edit'} {formData.table}</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          <Form onSubmit={handleSubmit}>
          {Object.keys(formData.item ?? {}).map(field => (
              <Form.Group key={field}>
                <Form.Label>{field}</Form.Label>
                <Form.Control
                  type={formData.schema[field].type === 'integer' ? 'number' : 'text'}
                  name={field}
                  defaultValue={newRecord ? '' : formData.item[field]}
                  readOnly = {formData.schema[field].read_only}
                  required = {formData.schema[field].required}
                />
              </Form.Group>
            ))}
            <Button type="submit">{newRecord ? 'Add' : 'Update'}</Button>
          </Form>
        </Modal.Body>
        </Modal>
    </div>
  );
};

export default AdminPage;
